springCloud
    一、服务注册中心: 一个管理各微服务程序的服务中心，各微服务将自己注册进服务中心，并上传自己的信息
                    客户端或各微服务可以通过服务中心获取目标的地址

        CAP理论
        C:强一致性：所有节点时刻保持数据同步，执行结果只有成功或失败，如果还没有同步成功，则会拒绝请求
        A:可用性：每个请求都能在一定时间内被服务器处理，且得到一个准确的响应（成功或失败），即使某个服务器数据不是同步最新的，也会返回
        P:分区容错性：由于网络问题带来的，由于网络异常，导致某些分区不可达，网络被分为多个分区，但仍然能提供服务
        三者只能保证两者
        对于分布式系统，通常必须满足P，因此分为CP和AP

        1. Eureka：(AP)
            服务端Server：本身为服务注册中心
            客户端Client：连接注册中心

            服务发现discovery：发现服务注册中心上的各微服务信息

            eureka的自我保护机制：当一个微服务因为网络不通或分区故障导致断开时（没有收到微服务实例的心跳），但微服务本身是健康的
                                服务中心不会立刻将该微服务剔除，而是会保存该服务的信息一段时间，等待重新接收心跳后，可以复活

        2. zookeeper: (CP) 端口默认2181，无可视化工具（？）
            服务端和客户端都向服务注册中心写入子节点，存储注册信息
            调用远程端口应用必须开启负载均衡

        3. consul：(CP) 默认端口8500，可视化管理：localhost:8500
            服务端和客户端都向服务注册中心写入注册信息
            调用远程端口应用必须开启负载均衡


    二、服务调用

        负载均衡：将请求平摊地分配到多个服务器上，从而达到系统的高可用(HA)

        1. Ribbon是一套客户端的负载均衡和服务调用的工具：Ribbon+RestTemplate调用

            Nginx负载均衡是在服务端实现的，Ribbon是本地负载均衡，从注册中心获取服务信息列表后，再调用远程技术，也就是在客户端实现的

            负载均衡：
                集中式：服务端和客户端之间使用独立的LB（负载均衡）设施，该设施负责把请求通过某种策略转发给服务端（如Nginx）
                进程式：客户端从服务中心获取可用地址，再自己决策出一个服务地址访问（如Ribbon）

            Ribbon工作的两步骤：
                （1）从注册中心获取服务列表
                （2）自己选一个相对空闲的服务器地址访问

            Eureka、zookeeper、consul依赖包都是自带Ribbon依赖的，所以不用引入，@LoadBalanced注解就是实现负载均衡的

            RestTemplate:
                getForObject:返回对象为响应体中数据转化成的对象，基本可以理解为Json
                getForEntity:返回对象为ResponseEntity对象，包含响应中一些细化的信息，如响应头、响应码、响应体等

            IRule接口：Ribbon负载均衡的算法实现接口，在Ribbon里有很多种实现类，是不同的均衡方法，可以替换，默认为轮询

        2. Feign是一个声明式的Web服务客户端，让编写Web服务哭护短变得非常容易，只需要创建一个接口并在接口上添加注解即可，不用再调用RestTemplate
                让java Http客户端变得更容易，可以更简单的完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量
                Feign集成了Ribbon，是使用在客户端（消费端、调用端）的
           OpenFeign在Feign的基础上引入了SpringMVC的支持



    三、服务降级和服务熔断

        服务雪崩：多个服务连续逐级调用，如A调B，B调C，C又调其它微服务，若某个服务超时或不可用（由于网络问题是不可避免的），大量请求堆积在A，大量资源集中在A，导致系统崩溃

        Hystrix：用于处理分布式系统的延迟和容错
        断路器：本身是一种开关，都某个单元发生故障，通过断路器监控，向调用方返回一个符合预期的、可处理的备选响应，而不是长时间等待或抛出无法处理的异常
                从而保证服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩

            服务降级（fallback）：服务器忙，请稍后再试，不让客户等待并立刻返回一个友好的提示
                发出降级的情况：
                    *程序运行异常
                    *超时
                    *服务熔断出发服务降级
                    *线程池、信号量打满

                1.服务器处理超时，调用者不一直等待，服务降级 （服务器做处理）
                2.服务器宕机，无法处理，调用者等待超时，不再一直等待，服务降级（服务器做处理）
                3.服务器处理正确，调用者出现故障（如自己等待时间小于处理时间），自己处理降级

                方式一、服务器做降级保护处理：
                           *服务方法上添加@HystrixCommond注解，并添加转接的服务
                           *主启动类要添加@@EnableCircuitBreaker注解

                方式二、客户端做降级保护处理（常用）:
                           *yaml开启hystrix支持(开启后无法更改客户端等待时间，只能转接，若要更改时间还是需要配置为false同时在ribbon里配置时间）
                           *主启动类加@EnableHystrix(里面包含了@EnableCircuitBreaker注解)
                           *业务类服务方法上添加@HystrixCommond注解，并添加转接的服务

                解耦：
                    每个业务都对应一个兜底方法，导致代码膨胀，冗余且繁琐：定义一个全局的服务降级处理方法：全局服务降级方法不能携带参数
                        方法1：@DefaultProperties:没有配置过的，就用全局的；配置过的，就用自己的：这个是在客户端处理
                        方法2：定义接口实现类，实现服务降级方法（需开启yaml中hystrix支持）:这个是对于服务端错误的处理


            服务熔断（break）：类比保险丝，达到最大访问量后，直接拒绝访问，然后调用服务降级方法

                          *********************************************************
                          *********************************************************
                          *******当检测到该节点微服务调用响应正常后,恢复调用链路*******
                          *********************************************************
                          *********************************************************

                  熔断打开：服务端大量出错时，不再允许访问当前服务，全部转为服务降级，但一般有熔断时间（可设置）
                  熔断关闭：不会对服务进行熔断
                  熔断半开：一定时间后，部分请求根据规则调用当前服务，如果请求成功且符合规则则认为当前服务恢复正常，关闭熔断


                  1、当满足一定的阈值的时候（默认10秒内超过20个请求次数）且当失败率达到一定的时候（默认10秒内超过50%的请求失败）；
                  3、到达以上阈值，断路器将会开启；
                  4、当开启的时候，所有请求都不会进行转发；
                  5、一段时间之后（默认是5秒），这个时候断路器是半开状态，会让其中一个请求进行转发；如果成功，断路器会关闭，若失败，继续开启。重复4和5。


            服务限流（flowlimit）：高并发操作时，严禁一窝蜂的拥挤，执行排队，一秒N个，有序进行

        hystrix监控程序:dashboard


    四、服务网关：外部请求->负载均衡->网关->微服务

             Geteway：为微服务架构提供一种简单有效的统一的API路由管理方式（基于异步非阻塞模型开发的）
                同步和异步是针对于客户端来说：同步必须等到响应了才处理下一个，而异步可以在等待响应的同时，处理其他事务
                阻塞和非阻塞是针对于服务端：服务端需要等前面的响应处理完返回结果，才能处理下一个，后续请求就会一直等待；非阻塞可以同时执行其他响应结果

                功能：反向代理、鉴权、流量控制、熔断、日志监控......

                gateway工作内容：路由（先寻找目标服务器）、断言（是否存在匹配路径）、过滤（在服务前后添加一些功能，执行放行或阻拦）
                        gateway向外统一暴露一个网关地址，客户端直接访问，网关路由寻找目标服务器时需要实现负载均衡，不再是ribbon+restTemplate或者feign方式，动态创建路由功能



    五、服务配置：

            Spring Cloud Config：分布式配置中心  可以统一配置相同的配置文件部分（集中、动态的配置管理），避免每一个服务都要配置重复的application.yaml文件

                分为服务端和客户端两部分

    六、服务消息总线：

            分布式自动刷新配置功能
                ● GitHub上的配置文件修改后，可否广播一下，不用每个微服务都通过发送POST请求动态刷新。
                ● 可不可以该刷新的刷新，不想刷新的不刷新

        Springcloud Bus
               1.利用消息总线触发一个客户端/bus/refresh，而刷新所有客户端的配置
               2.利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置(更合适)
            在config服务端和客户端都需要添加消息总线支持，添加rabbitmq的依赖，并在配置文件中设置


